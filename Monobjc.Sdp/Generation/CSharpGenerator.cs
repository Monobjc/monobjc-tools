//
// This file is part of Monobjc, a .NET/Objective-C bridge
// Copyright (C) 2007-2011 - Laurent Etiemble
//
// Monobjc is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// Monobjc is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Monobjc.  If not, see <http://www.gnu.org/licenses/>.
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Monobjc.Tools.Sdp.Model;

namespace Monobjc.Tools.Sdp.Generation
{
    /// <summary>
    /// Generate a wrapper by using the C# language.
    /// </summary>
    public class CSharpGenerator : Generator
    {
        protected override String Extension { get { return ".cs"; } }

        protected override string Generate(GenerationContext context)
        {
            StringBuilder builder = new StringBuilder();

            GenerateHeader(builder);
            GenerateUsings(builder);

            // Output namespace
            builder.AppendLine("namespace Monobjc.ScriptingBridge." + context.Prefix);
            builder.AppendLine("{");

            // Output enumerations
            GenerateEnumerations(builder, context);

            // Output application class
            @class appCls = context.Classes.FirstOrDefault(c => c.name == "application");
            if (appCls == null)
            {
                throw new NotSupportedException("No application found");
            }
            GenerateClass(builder, context, appCls);

            // Output other classes
            foreach (@class cls in context.Classes.Where(c => c.name != "application"))
            {
                GenerateClass(builder, context, cls);
            }

            builder.AppendLine("}");

            return builder.ToString();
        }

        private static void GenerateHeader(StringBuilder builder)
        {
            builder.AppendLine("//");
            builder.AppendLine("// This file was generated by the Monobjc SDP tool");
            builder.AppendLine("//");
            builder.AppendLine("// DO NOT ALTER UNLESS YOU KNOW WHAT YOU DO");
            builder.AppendLine("//");
        }

        private static void GenerateUsings(StringBuilder builder)
        {
            builder.AppendLine("using System;");
            builder.AppendLine("using Monobjc;");
            builder.AppendLine("using Monobjc.Foundation;");
            builder.AppendLine("using Monobjc.AppKit;");
            builder.AppendLine("using Monobjc.ScriptingBridge;");
            builder.AppendLine();
        }

        private static void GenerateClass(StringBuilder builder, GenerationContext context, @class cls)
        {
            String className = context.ConvertType(cls.name, false);
            String baseClassName;
            if (cls.name == "application")
            {
                baseClassName = "SBApplication";
            }
            else
            {
                baseClassName = String.IsNullOrEmpty(cls.inherits) ? "SBObject" : context.ConvertType(cls.inherits, false);
            }

            builder.AppendLine("\t/// <summary>");
            builder.AppendFormat("\t/// {0}", cls.description);
            builder.AppendLine();
            builder.AppendLine("\t/// </summary>");

            builder.AppendFormat("\tpublic partial class {0} : {1}", className, baseClassName);
            builder.AppendLine();
            builder.AppendLine("\t{");

            builder.AppendFormat("\t\tpublic {0}() : base() {{}}", className);
            builder.AppendLine();
            builder.AppendLine();
            builder.AppendFormat("\t\tpublic {0}(IntPtr pointer) : base(pointer) {{}}", className);
            builder.AppendLine();
            builder.AppendLine();

            //
            // Output elements
            //
            builder.AppendLine("#region ----- Elements -----");
            foreach (element element in context.GetElementsFor(cls).OrderBy(e => e.type))
            {
                String value;
                @class typeCls = context.Classes.FirstOrDefault(c => String.Equals(c.name, element.type));
                if (typeCls != null)
                {
                    // Make sure that we use the correct plural
                     value = typeCls.plural ?? typeCls.name + "s";
                }
                else
                {
                    // Use the default name
                     value = element.type;
                }
                String elementName = NamingHelper.GenerateDotNetName(String.Empty, value);
                String elementMessage = NamingHelper.GenerateObjCName(value);

                // Output the code
                builder.AppendFormat("\t\tpublic SBElementArray {0}", elementName);
                builder.AppendLine();
                builder.AppendLine("\t\t{");
                builder.AppendFormat("\t\t\tget {{ return ObjectiveCRuntime.SendMessage<SBElementArray>(this, \"{0}\"); }}", elementMessage);
                builder.AppendLine();
                builder.AppendLine("\t\t}");
                builder.AppendLine();
            }
            builder.AppendLine("#endregion");
            builder.AppendLine();

            //
            // Output properties
            //
            builder.AppendLine("#region ----- Properties -----");
            foreach (property property in context.GetPropertiesFor(cls).OrderBy(p => p.name))
            {
                String propertyType = context.ConvertType(property.type, true);
                String propertyName = NamingHelper.GenerateDotNetName(String.Empty, property.name);

                builder.AppendFormat("\t\tpublic {0} {1}", propertyType, propertyName);
                builder.AppendLine();
                builder.AppendLine("\t\t{");

                // Generate getter
                switch (property.access)
                {
                    case propertyAccess.r:
                    case propertyAccess.rw:
                        {
                            String selector = NamingHelper.GenerateObjCName(property.name);
                            builder.AppendFormat("\t\t\tget {{ return ObjectiveCRuntime.SendMessage<{0}>(this, \"{1}\"); }}", propertyType, selector);
                            builder.AppendLine();
                            break;
                        }
                    default:
                        break;
                }

                // Generate setter
                switch (property.access)
                {
                    case propertyAccess.rw:
                    case propertyAccess.w:
                        {
                            String selector = "set" + propertyName + ":";
                            builder.AppendFormat("\t\t\tset {{ ObjectiveCRuntime.SendMessage(this, \"{0}\", value); }}", selector);
                            builder.AppendLine();
                            break;
                        }
                    default:
                        break;
                }

                builder.AppendLine("\t\t}");
                builder.AppendLine();
            }
            builder.AppendLine("#endregion");
            builder.AppendLine();

            //
            // Output methods
            //
            builder.AppendLine("#region ----- Commands -----");
            IEnumerable<command> commands = context.GetCommandsFor(cls);
            foreach (command command in commands.OrderBy(c => c.name))
            {
                String returnType = command.result != null ? context.ConvertType(command.result.type1, true) : "void";

                // Builds the method name
                String methodName = NamingHelper.GenerateDotNetName(String.Empty, command.name);
                if (command.parameter != null)
                {
                    methodName = command.parameter.Aggregate(methodName, (name, p) => name += NamingHelper.GenerateDotNetName(String.Empty, p.name));
                }

                // Builds the signature
                String signature = String.Format("\t\tpublic {0} {1}(", returnType, methodName);
                List<String> parameters = new List<String>();
                if (command.parameter != null)
                {
                    foreach (parameter parameter in command.parameter)
                    {
                        String parameterName = NamingHelper.GenerateObjCName(parameter.name);
                        parameters.Add(context.ConvertType(parameter.type1, true) + " " + GenerationContext.ConvertParameterName(parameterName));
                    }
                }
                signature += String.Join(", ", parameters.ToArray());
                signature += ")";

                builder.Append(signature);
                builder.AppendLine();
                builder.AppendLine("\t\t{");

                // Builds the invocation
                String invocation = "";
                if (command.result != null)
                {
                    invocation += "return ";
                }
                invocation += "ObjectiveCRuntime.SendMessage";
                if (command.result != null)
                {
                    invocation += String.Format("<{0}>", returnType);
                }
                invocation += String.Format("(this, \"{0}\"", NamingHelper.GenerateObjCSelector(command));
                if (command.parameter != null)
                {
                    foreach (parameter parameter in command.parameter)
                    {
                        String parameterName = NamingHelper.GenerateObjCName(parameter.name);
                        parameterName = GenerationContext.ConvertParameterName(parameterName);
                        invocation += String.Format(", {0}", parameterName);
                    }
                }
                invocation += ");";

                builder.AppendFormat("\t\t\t{0}", invocation);
                builder.AppendLine();

                builder.AppendLine("\t\t}");
                builder.AppendLine();
            }
            builder.AppendLine("#endregion");
            builder.AppendLine();

            builder.AppendLine("\t}");
            builder.AppendLine();
        }

        private static void GenerateEnumerations(StringBuilder builder, GenerationContext context)
        {
            foreach (enumeration enumeration in context.Enumerations)
            {
                GenerateEnumeration(builder, context, enumeration);
            }
        }

        private static void GenerateEnumeration(StringBuilder builder, GenerationContext context, enumeration enumeration)
        {
            String enumerationName = NamingHelper.GenerateDotNetName(context.Prefix, enumeration.name);

            builder.AppendFormat("\tpublic enum {0} : uint", enumerationName);
            builder.AppendLine();
            builder.AppendLine("\t{");
            IEnumerable<enumerator> values = enumeration.Items.Where(i => i is enumerator).Cast<enumerator>();
            foreach (enumerator value in values)
            {
                String valueName = NamingHelper.GenerateDotNetName(enumerationName, value.name);
                if (!String.IsNullOrEmpty(value.code))
                {
                    builder.AppendFormat("\t\t{0} = 0x{1}, // '{2}'", valueName, NamingHelper.ToUInt32(value.code).ToString("X8"), value.code);
                }
                else
                {
                    builder.AppendFormat("\t\t{0},", valueName);
                }
                builder.AppendLine();
            }
            builder.AppendLine("\t}");
            builder.AppendLine();
        }
    }
}